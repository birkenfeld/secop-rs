// -----------------------------------------------------------------------------
// Rust SECoP playground
//
// This program is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free Software
// Foundation; either version 2 of the License, or (at your option) any later
// version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
// details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc.,
// 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// Module authors:
//   Georg Brandl <g.brandl@fz-juelich.de>
//
// -----------------------------------------------------------------------------
//
//! Derive a SECoP ModuleBase implementation for individual modules.
//!
//! Provides an implementation of the `ModuleBase` trait for a given struct,
//! which contains the custom data required for a module's hardware-facing
//! implementation.
//!
//! Additionally, the struct must have a member called `internals` of type
//! `secop::module::ModInternals`, which represents the basic data and
//! communication interfaces that this framework requires for each module, and a
//! member called `cache` of type `<Struct>ParamCache` (generated by the derive
//! macro), which is a store of all previous parameter values and timestamps.
//!
//! Parameters and commands are added to the module interface using attributes.
//! For example:
//!
//! ```
//! #[derive(ModuleBase)]
//! #[param(name="status", datatype="StatusType", readonly=True)]
//! #[param(name="value", datatype="Double", readonly=True)]
//! #[param(name="target", datatype="Double")]
//! #[param(name="speed", datatype="DoubleFrom(0.0)", default="1.0")]
//! #[command(name="stop", argtype="None", restype="None")]
//! struct Motor {
//!     // required by the framework
//!     internals: ModInternals,
//!     cache: MotorParamCache,
//!     // module specific, to talk to the controller
//!     connection: SerialPort,
//! }
//! ```
//!
//! You must afterwards also implement the `Module` trait, which contains all
//! APIs that cannot be derived automatically, and inherent methods that
//! implement the actual reading, writing, and execution.  These have very
//! simple signatures since all data is in terms of Rust types, and has been
//! validated against the SECoP type specification.  For the above example:
//!
//! ```
//! impl Module for Motor {
//!     fn create(internals: ModInternals) -> Self {
//!         // create the serial port, using internals.config to access the
//!         // user configuration of the module
//!         let connection = ...;
//!         Motor { internals, connection }
//!     }
//! }
//!
//! impl Motor {
//!     fn read_value(&mut self) -> Result<f64> { ... }
//!     fn write_target(&mut self, tgt: f64) -> Result<()> { ... }
//!     fn do_stop(&mut self, arg: ()) -> Result<()> { ... }
//! }
//! ```

use std::collections::HashSet;
use syn::{Expr, Ident, spanned::Spanned};
use proc_macro2::Span;
use quote::{quote, quote_spanned};
use darling::FromMeta;


/// Representation of the #[param(...)] attribute.
#[derive(FromMeta, Debug)]
struct SecopParam {
    name: String,
    doc: String,
    datatype: String,
    readonly: bool,
    #[darling(default)]
    default: Option<String>,
    #[darling(default)]
    unit: String,
    #[darling(default)]
    group: String,
    #[darling(default = "default_polling")]
    polling: i64,
    #[darling(default = "default_visibility")]
    visibility: String,
}

// The default is to poll a parameter in every cycle.
fn default_polling() -> i64 { 1 }
fn default_visibility() -> String { "user".into() }

/// Representation of the #[command(...)] attribute.
#[derive(FromMeta, Debug)]
struct SecopCommand {
    name: String,
    doc: String,
    argtype: String,
    restype: String,
    #[darling(default)]
    group: String,
    #[darling(default = "default_visibility")]
    visibility: String,
}


fn parse_attr<T: FromMeta>(attr: &syn::Attribute) -> Result<T, proc_macro2::TokenStream> {
    attr.parse_meta()
        .map_err(|err| format!("invalid param attribute: {}", err))
        .and_then(|meta| T::from_meta(&meta).map_err(|_| "could not parse this attribute".into()))
        .map_err(|e| quote_spanned! { attr.span() => compile_error!(#e); })
}

pub fn derive_module(input: synstructure::Structure) -> proc_macro2::TokenStream {
    let mut params = Vec::new();
    let mut commands = Vec::new();

    let vis = &input.ast().vis;
    let param_cache_name = Ident::new(&format!("{}ParamCache", input.ast().ident),
                                      Span::call_site());

    // parse parameter and command attributes on the main struct
    for attr in &input.ast().attrs {
        if attr.path.segments[0].ident == "param" {
            match parse_attr::<SecopParam>(attr) {
                Ok(param) => params.push(param),
                Err(err) => return err
            }
        } else if attr.path.segments[0].ident == "command" {
            match parse_attr::<SecopCommand>(attr) {
                Ok(cmd) => commands.push(cmd),
                Err(err) => return err
            }
        }
    }

    // TODO: check that the members include "internals" and "cache".

    let mut lc_names = HashSet::new();

    // prepare snippets of code to generate
    let mut statics = vec![];
    let mut par_read_arms = vec![];
    let mut par_write_arms = vec![];
    let mut cmd_arms = vec![];
    let mut descriptive = vec![];
    let mut param_cache = vec![];
    let mut poll_busy_params = vec![];
    let mut poll_other_params = vec![];
    let mut activate_updates = vec![];
    let mut init_params_write = vec![];
    let mut init_params_read = vec![];

    for p in params {
        let SecopParam { name, doc, readonly, datatype, unit, group,
                         polling, default, visibility } = p;

        if !lc_names.insert(name.to_lowercase()) {
            panic!("param/cmd name {} is not unique", name)
        }

        // TODO: make this a proper enum?
        if visibility != "none" && visibility != "user" && visibility != "advanced" &&
            visibility != "expert"
        {
            panic!("visibility {:?} is not an allowed value for param {}", visibility, name);
        }

        let type_static = Ident::new(&format!("PAR_TYPE_{}", name), Span::call_site());
        let type_expr = syn::parse_str::<Expr>(&datatype).expect("unparseable datatype");
        let read_method = Ident::new(&format!("read_{}", name), Span::call_site());
        let write_method = Ident::new(&format!("write_{}", name), Span::call_site());
        let name_id = Ident::new(&name, Span::call_site());
        param_cache.push(quote! {
            #name_id: secop_core::module::CachedParam<<datatype_type!(#type_expr) as TypeDesc>::Repr>,
        });
        statics.push(quote! {
            static ref #type_static: datatype_type!(#type_expr) = #type_expr;
        });
        // TODO: catch and log errors
        par_read_arms.push(quote! {
            #name => {
                let read_value = self.#read_method()?;
                let (value, time, send) = self.cache.#name_id.update(read_value, &*#type_static)?;
                if send {
                    self.send_update(#name, value.clone(), time);
                }
                (value, time)
            }
        });
        // TODO: catch and log errors
        par_write_arms.push(if p.readonly { quote! {
            #name => Err(Error::new(ErrorKind::ReadOnly, ""))
        } } else { quote! {
            #name => {
                self.#write_method(#type_static.from_json(&value)?)?;
                self.read(#name)
            }
        } });
        if polling != 0 {
            let polling_period = polling.abs() as usize;
            let poll_it = quote! {
                if n % #polling_period == 0 {
                    // TODO: error handling?
                    let _ = self.read(#name);
                }
            };
            if polling > 0 {
                poll_busy_params.push(poll_it);
            } else {
                poll_other_params.push(poll_it);
            }
        }
        activate_updates.push(quote! {
            // TODO: really ignore errors?
            if let Ok(value) = #type_static.to_json(self.cache.#name_id.data()) {
                res.push(Msg::Update { module: self.name().to_string(),
                                       param: #name.to_string(),
                                       data: json!([value, {"t": self.cache.#name_id.time()}]) });
            }
        });

        // TODO: handle errors better, in particular, isolate failures and log them
        // with the parameter name given.
        if let Some(def) = default {
            // default is given: use it
            if readonly {
                panic!("parameter {} cannot have a default since it is readonly", name);
            }
            let def_expr = syn::parse_str::<Expr>(&def).unwrap_or_else(
                |e| panic!("unparseable default value for param {}: {}", name, e));
            init_params_write.push(quote! {
                let value = if let Some(val) = self.config().parameters.get(#name) {
                    val.clone()
                } else {
                    #type_static.to_json(#def_expr)?
                };
                // This will emit an update message, but since the server is starting
                // up, we can assume it hasn't been activated yet.
                self.change(#name, value)?;
            });
        } else {
            if !readonly {
                init_params_read.push(quote! {
                    if let Some(val) = self.config().parameters.get(#name) {
                        self.change(#name, val.clone())?;
                    } else {
                        self.read(#name)?;
                    }
                })
            } else {
                // no default and readonly: call read method
                init_params_read.push(quote! {
                    self.read(#name)?;
                });
            }
        }

        if visibility != "none" {
            let unit_entry = if !unit.is_empty() {
                quote! { "unit": #unit, }
            } else { quote! {} };
            descriptive.push(quote! {
                json!([#name, {
                    "description": #doc,
                    "datatype": #type_static.type_json(),
                    "readonly": #readonly,
                    "group": #group,
                    "visibility": #visibility,
                    #unit_entry
                }]),
            });
        }
    }

    for c in commands {
        let SecopCommand { name, doc, argtype, restype, group, visibility } = c;

        if !lc_names.insert(name.to_lowercase()) {
            panic!("param/cmd name {} is not unique", name)
        }

        if visibility != "none" && visibility != "user" && visibility != "advanced" &&
            visibility != "expert"
        {
            panic!("visibility {:?} is not an allowed value for command {}", visibility, name);
        }
        let argtype_static = Ident::new(&format!("CMD_ARG_{}", name), Span::call_site());
        let argtype_expr = syn::parse_str::<Expr>(&argtype).expect("unparseable datatype");
        let restype_static = Ident::new(&format!("CMD_RES_{}", name), Span::call_site());
        let restype_expr = syn::parse_str::<Expr>(&restype).expect("unparseable datatype");
        let do_method = Ident::new(&format!("do_{}", name), Span::call_site());
        statics.push(quote! {
            static ref #argtype_static : datatype_type!(#argtype_expr) = #argtype_expr;
            static ref #restype_static : datatype_type!(#restype_expr) = #restype_expr;
        });
        // TODO: catch and log errors
        cmd_arms.push(quote! {
            #name => {
                let result_r = self.#do_method(#argtype_static.from_json(&arg)?)?;
                let result = #restype_static.to_json(result_r)?;
                Ok(json!([result, {"t": localtime()}]))
            }
        });
        if visibility != "none" {
            descriptive.push(quote! {
                json!([#name, {
                    "description": #doc,
                    "datatype": ["command", #argtype_static.type_json(),
                                 #restype_static.type_json()],
                    "group": #group,
                    "visibility": #visibility,
                }]),
            });
        }
    }

    let poll_busy_params = &poll_busy_params;

    // generate the final code!
    let generated_impl = input.gen_impl(quote! {
        use serde_json::{Value, json};
        use lazy_static::{lazy_static, __lazy_static_internal, __lazy_static_create};
        use mlzutil::time::localtime;
        use secop_core::errors::{Error, ErrorKind, Result};
        use secop_core::proto::Msg;
        use secop_core::module::ModuleBase;

        lazy_static! {
            #( #statics )*
        }

        gen impl ModuleBase for @Self {
            fn internals(&self) -> &ModInternals { &self.internals }

            fn describe(&self) -> Value {
                let accessibles = vec![
                    #( #descriptive )*
                ];
                json!([self.name(), {
                    "description": self.config().description,
                    "interface_class": ["Drivable"], // TODO
                    "features": [],
                    "visibility": "user", // TODO
                    "group": self.config().group,
                    "accessibles": accessibles
                }])
            }

            fn read(&mut self, param: &str) -> Result<Value> {
                let (value, time) = match param {
                    #( #par_read_arms, )*
                    _ => return Err(Error::no_param())
                };
                Ok(json!([value, {"t": time}]))
            }

            fn change(&mut self, param: &str, value: Value) -> Result<Value> {
                match param {
                    #( #par_write_arms, )*
                    _ => Err(Error::no_param())
                }
            }

            fn command(&mut self, cmd: &str, arg: Value) -> Result<Value> {
                match cmd {
                    #( #cmd_arms, )*
                    _ => Err(Error::no_command())
                }
            }

            fn activate_updates(&mut self) -> Vec<Msg> {
                let mut res = Vec::new();
                #( #activate_updates )*
                res
            }

            fn init_params(&mut self) -> Result<()> {
                // Initials that are written are processed first, so that the initial
                // read for the other parameters makes use of the written ones already.
                #( #init_params_write )*
                #( #init_params_read )*
                Ok(())
            }

            fn poll_normal(&mut self, n: usize) {
                if self.cache.status.as_ref().0 != StatusConst::Busy {
                    #( #poll_busy_params )*
                }
                #( #poll_other_params )*
            }

            fn poll_busy(&mut self, n: usize) {
                if self.cache.status.as_ref().0 == StatusConst::Busy {
                    #( #poll_busy_params )*
                }
            }
        }
    });
    let generated = quote! {
        #[derive(Default)]
        #vis struct #param_cache_name {
            #( #param_cache )*
        }

        #generated_impl
    };
    // println!("{}", generated);
    generated
}
